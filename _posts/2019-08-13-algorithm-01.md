---
layout:     post
title:      算法01 - 大O表示法
subtitle:    "\"大O表示法\""
date:       2019-08-13
author:     Lin
header-img: img/post-bg-coding0813.jpeg
catalog: true
tags:
    - algorithm
---

> 算法应该是一个思考工具，表达工具，而不是计算工具。
> 
> 首先，就是不要将视线局限在算法的细节里「每一个步骤代表什么意思，我应该如何去套用….」你要理解算法背后的思维方式，弄明白它到底是想表达一种什么逻辑？
> 
> 其次，你接着想一想，如果你现在面对一个小孩子，你会怎么描述这个算法呢？这个大白话的描述，很可能就是这个算法背后的那个思考方式。
> 
> 最后，把「具体的算法」抽象成为「思考方式」之后，就能将这个思维方式应用到其他地方了。

大O表示法是一种特殊的表示法，指出了算法的速度有多快。实际上，你经常要使用别人编写的算法，列如Java的JDK中我们见到的Collections.sort()和Arrays.sort()这两个排序算法等等，想更好地理解背后的逻辑，知道这些算法的速度大有裨益。

下面我们来看看大O表示法是什么，以及一些常见算法的运行时间。

## 不同的算法有不同的速度

先来看一个概念: 线性时间(`linear time`) -- 查询的次数与列表长度相同。

举个栗子，简单查找 逐个地检查数字，如果列表包含`100`个数字，做多需要查找`100`次。如果列表包含了`40`亿个数字，最多需要查找`40`亿次。

而[二分法查找](https://en.wikipedia.org/wiki/Binary_search_algorithm)则不一样了，`100`个元素列表只要最多查找`7`次；`40`亿个数字，最多查`32`次。

![](https://i.loli.net/2019/08/13/XroIZQODSgLkhac.jpg)

那么，我们一般是怎么来计算的呢？

## 大O表示法

以[算法图解](https://item.jd.com/12148832.html)的NASA查找算法为例，得出`简单查找`与`二分查找`的运行时间对比:

![](https://i.loli.net/2019/08/13/eT1HL5KnvuCVFlO.jpg)

随着元素数量的增加，二分查找需要的额外时间并不多，而简单查找需要的额外时间却很多。因此，随着列表的增长，二分查找的速度比简单查找快得多。

仅知道算法需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长而增加。这正是大O表示法的用武之地。使用大O表示法，这个运行时间为 O (n )。大O表示法让你能够比较操作数，它指出了算法运行时间的增速。

大O表示法说的是最糟的情形。

## 5种常见大O运行时间

* 对数时间：`O(log n)`，二分查找;
* 线性时间：`O(n)`，简单查找;
* `O(n * log n)`，快速排序——一种速度较快的排序算法;
* `O(n^2)`，选择排序——一种速度较慢的排序算法;
* `O(n!)`，旅行商问题的解决方案——一种非常慢的算法.

举个例子，绘制一个包含 16 格的网格，且有 5 种不同的算法可供选择，下面按从快到慢的顺序列出了使用这些算法绘制网格所需的时间:

![](https://i.loli.net/2019/08/13/Cjk8RbZ7SsXIvc9.jpg)

## 总结

* 算法的速度指的并非时间，而是操作数的增速。
* 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
* 算法的运行时间用大O表示法表示。
* O(log n) 比 O(n) 快，当需要搜索的元素越多时，前者比后者快得越多。

#### 参考

* [算法图解](https://item.jd.com/12148832.html)
